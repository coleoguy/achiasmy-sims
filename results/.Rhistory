# 2004. Distributions of exons and introns in the human genome.
# In silico biology, 4(4), pp.387-393.
# We expect the germline exome mutation
# rate to be on the order of 1.45 X 10-8  per bp per year
#CITE: Scally, A., The mutation rate in human evolution and demographic inference. 2016 Current opinion
# in genetics & development, 41, pp.36-43.
# CITE: Narasimhan VM, Rahbari R, Scally A, Wuster A, Mason D, Xue Y, Wright J, Trembath RC,
# Maher ER, van Heel DA, et al.: A direct multi-generational estimate of
# the human mutation rate from autozygous segments seen in thousands of
# parentally related individuals. bioRxiv 2016.
# if we take these numbers and then apply a generation time of 25 years
# we can us a binomial distribution to find the number of mutations that
# individuals will contain:
# the prob argument is created by multiplying the annual mutation rate
# by a generation time of 25y plus times two since we are dealing with diploids
#### Explanation of mutation rate choice ####
# normal and realistic 1.45e-08
if(is.null(mut.rate)) mut.rate <- 1.45e-8
mut.rate <- mut.rate * 25 * 2
# distribution of mutational effects to create something realistic
# we will use a compound normal distribution to describe the value of
# s where fitness is equal to 1+s
dfe <- rexp(5000,rate=3.5)-1
# values less than -1 are not meaninful
dfe <- dfe[dfe<=1]
# examine the looks of our mutations
#hist(dfe,breaks=100, xlim=c(-1,1))
#abline(v=0)
# strength of selection on sexually antagonistic locus
if(is.null(s.ant)) s.ant <- 0.5
# genetic architecture of the sexually antagonistic locus
if(is.null(h.ant)) h.ant <- .5
# genetic architecture of the sexually antagonistic locus
if(is.null(aneuploidy.rate)) aneuploidy.rate <- .01
pars <- list(N,
sites,
site.dist,
site.sdr,
site.sal,
site.ach,
dist.ach,
h.ant,
s.ant,
dfe,
mut.rate,
chromosome,
aneuploidy.rate)
names(pars) <- c("N",
"sites",
"site.dist",
"site.sdr",
"site.sal",
"site.ach",
"dist.ach",
"h.ant",
"s.ant",
"dfe",
"mut.rate",
"chromosome",
"aneuploidy.rate")
return(pars)
}
# this function initializes the population
get.initial.pop <- function(pars){
pop.xy <- list()
for(i in 1:pars$N){
pop.xy[[i]] <- matrix(1, 2, pars$sites)
# the SDR will have alleles of 0 and 1 representing X and Y resp.
pop.xy[[i]][, pars$site.sdr] <- sample(c(0,0,0,1), size=2)
# the SAL will have values of 0 and 1 representing female and male
# benefit alleles respectively
pop.xy[[i]][, pars$site.sal] <- sample(0:1, 2, replace=T)
}
return(pop.xy)
}
# this function calculates the fitness of a genome
get.fit <- function(genome, pars){
gen.fit <- (1:pars$sites)[-c(pars$site.sdr, pars$site.sal, pars$site.ach)]
gen.fit <- prod(colMeans(genome[,gen.fit]))
m.f <- 1
# males
if(sum(genome[,pars$site.sdr]) == 1){
switch(as.character(sum(genome[,pars$site.sal])),
"0" = s.f <- 1,
"1" = s.f <- 1 + pars$h.ant * pars$s.ant,
"2" = s.f <- 1 + pars$s.ant)
switch(as.character(sum(genome[,pars$site.ach])),
"0" = m.f <- 1 - pars$aneuploidy.rate,
"1" = m.f <- 1,
"2" = m.f <- 1)
}
# female
if(sum(genome[,pars$site.sdr]) == 0){
switch(as.character(sum(genome[,pars$site.sal])),
"0" = s.f <- 1,
"1" = s.f <- 1 / (1 + pars$h.ant * pars$s.ant),
"2" = s.f <- 1 / (1 + pars$s.ant))
}
t.fit <- gen.fit * s.f * m.f
t.fit[t.fit < 0] <- 0
return(t.fit)
}
# this function gives a vector of sexes
get.dams <- function(pop.xy){
females <- c()
for(i in 1:pars$N){
switch(as.character(sum(pop.xy[[i]][,pars$site.sdr])), #Julia: what does "switch" do for this funnction?
"0" = females[i] <- T,
"1" = females[i] <- F)
}
return(females)
}
# make parent table
get.parents <- function(pop.xy, pars){
parents <- matrix(, pars$N, 2)
colnames(parents) <- c("sire","dam")
fitness <- unlist(lapply(pop.xy, get.fit, pars))
dams <- get.dams(pop.xy)
fitness[!dams] <- fitness[!dams]/max(fitness[!dams])
fitness[dams] <- fitness[dams]/max(fitness[dams])
parents[, 1] <- sample(x = (1:pars$N)[!dams],
prob = fitness[!dams],
size = pars$N,
replace = T)
parents[, 2] <- sample(x = (1:pars$N)[dams],
prob = fitness[dams],
size = pars$N,
replace = T)
return(parents)
}
# this lays down mutations
radiate <- function(pop.xy, pars){
hit.indiv <- rbinom(n=pars$N,size=1588410, prob=pars$mut.rate)
for(i in 1:pars$N){
if(hit.indiv[i] != 0){
hit.sites <- (1:pars$sites)[-c(pars$site.sdr,
pars$site.sal,
pars$site.ach)]
hit.sites <- sample(x=hit.sites, size = hit.indiv[i])
for(j in 1:hit.indiv[i]){
pop.xy[[i]][sample(x=0:1, 1), hit.sites[j]] <- 1+sample(pars$dfe, 1)
}
}
}
return(pop.xy)
}
get.gamete <- function(genome, pars){
# this will hold strand information
strand <- c()
# this is for the case of chiasmatic meiosis
#TODO make sure this is females (checked: this is female)
if(sum(genome[,pars$site.sdr])==0){
if(sum(genome[, pars$site.ach]) == 2){
# find crossover spots
x <- which(sample(x=0:1,prob=c(.98,.02),replace=T,size=99)==1)+1
if(length(x) > 0){
for(i in 1:length(x)){
if(i == 1) strand <- rep(sample(x=1:2,1), times = x[i])
if(i > 1){
z <- x[i] - x[(i-1)]
switch(strand[length(strand)],
"1" = strand <- c(strand, rep(2, times=z)),
"2" = strand <- c(strand, rep(1, times=z)))
}
}
if(length(strand) < pars$sites){
z <- pars$sites - length(strand)
strand <- c(strand,
rep(strand[length(strand)], times=z))
}
}
if(length(x) == 0) strand <- rep(sample(1:2, 1), times=pars$sites)
}
# this is for the case of achiasmatic meiosis
if(sum(genome[, pars$site.ach]) < 2){
strand <- rep(sample(1:2, 1), times = pars$sites)
# for the case of autosomal achiasmatic mutation
if(pars$site.ach == 100){
if(pars$dist.ach == .5){
strand[length(strand)] <- sample(1:2, 1)
}
}
}
# we are now at the point that we have strand information
# for our gamete
l.genome <- c(genome[1, ], genome[2, ])
gamete <- l.genome[(strand - 1) * pars$sites + 1:pars$sites]
}
if(sum(genome[,pars$site.sdr])==1){
x <- sample(81:99, size=1)
start.strand <- sample(1:2,1)
strand <- rep(start.strand, times = x)
z <- pars$sites - length(strand)
if(start.strand==1) strand[(x+1):pars$sites] <- 2
if(start.strand==2) strand[(x+1):pars$sites] <- 1
l.genome <- c(genome[1, ], genome[2, ])
gamete <- l.genome[(strand - 1) * pars$sites + 1:pars$sites]
}
# FROM THIS POINT DOWN SHOULD BE GOOD - I THINK
# this is for the case of achiasmatic meiosis
if(sum(genome[, pars$site.ach]) < 2){
strand <- rep(sample(1:2, 1), times = pars$sites)
# for the case of autosomal achiasmatic mutation
if(pars$site.ach == 100){
if(pars$dist.ach == .5){
strand[length(strand)] <- sample(1:2, 1)
}
}
}
# we are now at the point that we have strand information
# for our gamete
l.genome <- c(genome[1, ], genome[2, ])
gamete <- l.genome[(strand - 1) * pars$sites + 1:pars$sites]
return(gamete)
}
# this makes offspring
get.offspring <- function(pop.xy, parents, pars){
pop.xy2 <- pop.xy
for(i in 1:length(pop.xy2)){
for(j in 1:ncol(parents)){
pop.xy2[[i]][1, ] <- get.gamete(pop.xy[[parents[i,1]]], pars)
pop.xy2[[i]][2, ] <- get.gamete(pop.xy[[parents[i,2]]], pars)
}
}
return(pop.xy2)
}
# this runs one generation
generation <- function(pop.xy, pars){
pop.xy.big <- do.call(rbind, pop.xy)
check.cols <- 1:pars$sites[-c(pars$site.sdr,
pars$site.sal,
pars$site.ach)]
for(i in check.cols){
if(length(unique(pop.xy.big[, i])) == 1){
pop.xy.big[, i] <- 1
}
}
pop.xy <- lapply(split(pop.xy.big, rep(1:(nrow(pop.xy.big)/2), each=2)), matrix, ncol=pars$sites)
pop.xy <- radiate(pop.xy, pars)
parents <- get.parents(pop.xy, pars)
pop.xy <- get.offspring(pop.xy, parents, pars)
return(pop.xy)
}
get.freqs <- function(pop.xy, pars){
x.alleles <- y.alleles <- c()
for(i in 1:pars$N){
genome <- pop.xy[[i]]
xs <- genome[, pars$site.sdr] == 0
x.alleles <- c(x.alleles, genome[xs, pars$site.sal])
ys <- genome[, pars$site.sdr] == 1
y.alleles <- c(y.alleles, genome[ys, pars$site.sal])
}
y <- sum(y.alleles)/length(y.alleles)
x <- sum(x.alleles)/length(x.alleles)
report <- data.frame(x,y)
colnames(report) <- c("X","Y")
row.names(report) <- "frequency of male benefit"
return(report)
}
# calculates heterozygosity probability that a
# site is heterozygous in population
get.het <- function(pop.xy, pars){
pop.xy.big <- do.call(rbind, pop.xy)
keep <- (1:pars$sites)[-c(pars$site.sdr,
pars$site.sal,
pars$site.ach)]
x <- 0
for(i in keep){
if(length(unique(pop.xy.big[,i])) > 1) x <- x + 1
}
return(x/97)
} #Julia: why do we return x/97
# get frequency of achiasmatic meiosis mutation
get.freq.ach <- function(pop.xy, pars){
males <- !get.dams(pop.xy)
ach.alleles <- 0
for(i in 1:pars$N){
genome <- pop.xy[[i]]
if(pars$chromosome=="Y"){
if(males[i]){
ach.alleles <- ach.alleles + sum(genome[1, pars$site.ach] == 0)
}
}
if(pars$chromosome=="X"){
if(!males[i]){
ach.alleles <- ach.alleles + sum(genome[1:2, pars$site.ach] == 0)
}
if(males[i]){
ach.alleles <- ach.alleles + sum(genome[2, pars$site.ach] == 0)
}
}
if(pars$chromosome=="A"){
if(!males[i]){
ach.alleles <- ach.alleles + sum(genome[1:2, pars$site.ach] == 0)
}
if(males[i]){
ach.alleles <- ach.alleles + sum(genome[1:2, pars$site.ach] == 0)
}
}
}
x.count <- sum(get.dams(pop.xy))*2 + sum(!get.dams(pop.xy))
y.count <- sum(!get.dams(pop.xy))
if(pars$chromosome=="Y") ach.freq <- ach.alleles/y.count
if(pars$chromosome=="X") ach.freq <- ach.alleles/x.count
if(pars$chromosome=="A") ach.freq <- ach.alleles/(pars$N*2)
return(ach.freq)
}
# get frequency of achiasmatic meiosis mutation
achMut <- function(pop.xy, pars){
males <- !get.dams(pop.xy)
hit <- sample(which(males), 1)
if(pars$chromosome == "Y") pop.xy[[hit]][1 ,pars$site.ach] <- 0
if(pars$chromosome == "X") pop.xy[[hit]][2 ,pars$site.ach] <- 0
if(pars$chromosome == "A") pop.xy[[hit]][sample(1:2, 1) ,pars$site.ach] <- 0
return(pop.xy)
}
library(doMC)
registerDoMC(7)
mut.rates <- c(1.45e-8,
#1.45e-10,
1.45e-12)
N <- 1000
gens <- 250
iter <- 100
chroms <- c("X","Y","A")
positions <- c(60,60,100)
all.results <- vector(length=3, mode="list")
names(all.results) <- chroms
for(k in 1:3){
print(paste("running", chroms[k], "chromosome model"))
# set up container for results
results.time <- vector(length=length(mut.rates), mode="list")
names(results.time) <- mut.rates
# loops through and tests each mutation rate
for(j in 1:length(mut.rates)){
print(paste("runnning mutation rate:", j, "of", length(mut.rates)))
pars <- get.pars(N = N,
s.ant = .5,
aneuploidy.rate = 0.1, # TODO run at .1 and 0
site.sdr = 5,
h.ant = 0.5,
site.sal = 50,
site.ach = positions[k],
mut.rate = mut.rates[j],
chromosome = chroms[k]) #1.45e-8
starting.pop <- get.initial.pop(pars)
x <- foreach(k=1:iter, .combine = "rbind") %dopar%{
time.table <- c()
pop <- starting.pop
segregating <- T
counter <- 1
while(segregating){
pop <- generation(pop, pars)
cur.freq <- get.freq.ach(pop, pars)
time.table[counter] <- cur.freq
if(counter == gens) segregating <- F
if(cur.freq == 1){
time.table[length(time.table):gens] <- 1
segregating <- F
}
if(counter %% 10 == 0) pop <- achMut(pop, pars)
counter <- counter + 1
}
time.table
}
results.time[[j]] <- x
}
all.results[[k]] <- results.time
}
save.image("~/Dropbox/achiasmatic.evolve/results/aneuploidy rerun (0.1) 2.RData")
load("~/Dropbox/achiasmatic.evolve/results/aneuploidy (0.0) rerun 2.RData")
#frequency of meiosis mutation for given iteration
library(viridis)
cols <- viridis(100)
par(pty="s")
par(mfcol=c(1,2))
# Y chromosome
for (j in 1:2){
plot(x=1:250, y=all.results[[2]][[j]][1,], col=cols[1], type = "l",
xlab="Generation", ylab="Frequency", xlim=c(0,300), ylim=c(0,1),lwd=.05)
#i should go from 2 to the number of iterations
for(i in 2:100){
lines(x=1:250, y=all.results[[2]][[j]][i,], col=cols[i],lwd=.05)
}
fixed <- sum(all.results[[2]][[j]][,250]==1)
lost <- sum(all.results[[2]][[j]][,250]==0)
text(x=245, y=.95, fixed, pos=4)
text(x=245, y=.05, lost, pos=4)
}
# X chromosome
for (j in 1:2){
plot(x=1:250, y=all.results[[1]][[j]][1,], col=cols[1], type = "l",
xlab="Generation", ylab="Frequency", xlim=c(0,300), ylim=c(0,1),lwd=.05)
#i should go from 2 to the number of iterations
for(i in 2:100){
lines(x=1:250, y=all.results[[1]][[j]][i,], col=cols[i],lwd=.05)
}
fixed <- sum(all.results[[1]][[j]][,250]==1)
lost <- sum(all.results[[1]][[j]][,250]==0)
text(x=245, y=.95, fixed, pos=4)
text(x=245, y=.05, lost, pos=4)
}
# autosome
for (j in 1:2){
plot(x=1:250, y=all.results[[3]][[j]][1,], col=cols[1], type = "l",
xlab="Generation", ylab="Frequency", xlim=c(0,300), ylim=c(0,1),lwd=.05)
#i should go from 2 to the number of iterations
for(i in 2:100){
lines(x=1:250, y=all.results[[3]][[j]][i,], col=cols[i],lwd=.05)
}
fixed <- sum(all.results[[3]][[j]][,250]==1)
lost <- sum(all.results[[3]][[j]][,250]==0)
text(x=245, y=.95, fixed, pos=4)
text(x=245, y=.05, lost, pos=4)
}
#frequency of meiosis mutation for given iteration
library(viridis)
cols <- viridis(100)
par(pty="s")
par(mfcol=c(1,2))
# Y chromosome
for (j in 1:2){
plot(x=1:250, y=all.results[[2]][[j]][1,], col=cols[1], type = "l",
xlab="Generation", ylab="Frequency", xlim=c(0,300), ylim=c(0,1),lwd=.05)
#i should go from 2 to the number of iterations
for(i in 2:100){
lines(x=1:250, y=all.results[[2]][[j]][i,], col=cols[i],lwd=.05)
}
fixed <- sum(all.results[[2]][[j]][,250]==1)
lost <- sum(all.results[[2]][[j]][,250]==0)
text(x=245, y=.95, fixed, pos=4)
text(x=245, y=.05, lost, pos=4)
}
View(pars)
# X chromosome
for (j in 1:2){
plot(x=1:250, y=all.results[[1]][[j]][1,], col=cols[1], type = "l",
xlab="Generation", ylab="Frequency", xlim=c(0,300), ylim=c(0,1),lwd=.05)
#i should go from 2 to the number of iterations
for(i in 2:100){
lines(x=1:250, y=all.results[[1]][[j]][i,], col=cols[i],lwd=.05)
}
fixed <- sum(all.results[[1]][[j]][,250]==1)
lost <- sum(all.results[[1]][[j]][,250]==0)
text(x=245, y=.95, fixed, pos=4)
text(x=245, y=.05, lost, pos=4)
}
# autosome
for (j in 1:2){
plot(x=1:250, y=all.results[[3]][[j]][1,], col=cols[1], type = "l",
xlab="Generation", ylab="Frequency", xlim=c(0,300), ylim=c(0,1),lwd=.05)
#i should go from 2 to the number of iterations
for(i in 2:100){
lines(x=1:250, y=all.results[[3]][[j]][i,], col=cols[i],lwd=.05)
}
fixed <- sum(all.results[[3]][[j]][,250]==1)
lost <- sum(all.results[[3]][[j]][,250]==0)
text(x=245, y=.95, fixed, pos=4)
text(x=245, y=.05, lost, pos=4)
}
View(pars)
load("~/Dropbox/achiasmatic.evolve/results/aneuploidy rerun (0.1) 2.RData")
View(pars)
#frequency of meiosis mutation for given iteration
library(viridis)
cols <- viridis(100)
par(pty="s")
par(mfcol=c(1,2))
# Y chromosome
for (j in 1:2){
plot(x=1:250, y=all.results[[2]][[j]][1,], col=cols[1], type = "l",
xlab="Generation", ylab="Frequency", xlim=c(0,300), ylim=c(0,1),lwd=.05)
#i should go from 2 to the number of iterations
for(i in 2:100){
lines(x=1:250, y=all.results[[2]][[j]][i,], col=cols[i],lwd=.05)
}
fixed <- sum(all.results[[2]][[j]][,250]==1)
lost <- sum(all.results[[2]][[j]][,250]==0)
text(x=245, y=.95, fixed, pos=4)
text(x=245, y=.05, lost, pos=4)
}
# X chromosome
for (j in 1:2){
plot(x=1:250, y=all.results[[1]][[j]][1,], col=cols[1], type = "l",
xlab="Generation", ylab="Frequency", xlim=c(0,300), ylim=c(0,1),lwd=.05)
#i should go from 2 to the number of iterations
for(i in 2:100){
lines(x=1:250, y=all.results[[1]][[j]][i,], col=cols[i],lwd=.05)
}
fixed <- sum(all.results[[1]][[j]][,250]==1)
lost <- sum(all.results[[1]][[j]][,250]==0)
text(x=245, y=.95, fixed, pos=4)
text(x=245, y=.05, lost, pos=4)
}
# autosome
for (j in 1:2){
plot(x=1:250, y=all.results[[3]][[j]][1,], col=cols[1], type = "l",
xlab="Generation", ylab="Frequency", xlim=c(0,300), ylim=c(0,1),lwd=.05)
#i should go from 2 to the number of iterations
for(i in 2:100){
lines(x=1:250, y=all.results[[3]][[j]][i,], col=cols[i],lwd=.05)
}
fixed <- sum(all.results[[3]][[j]][,250]==1)
lost <- sum(all.results[[3]][[j]][,250]==0)
text(x=245, y=.95, fixed, pos=4)
text(x=245, y=.05, lost, pos=4)
}
View(pars)
load("~/Dropbox/achiasmatic.evolve/results/aneuploidy (0.0) rerun 2.RData")
View(pars)
load("~/Dropbox/achiasmatic.evolve/results/no aneuploidy rerun .RData")
View(pars)
