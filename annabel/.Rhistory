NF.FitnessTracker <- rbind(NF.FitnessTracker, DuplicatedRows)
NF.FitnessTracker <- subset(NF.FitnessTracker, `Paternal Lineage` != HigherOrder[p])
}
}
Tips <- c()
HigherOrder <- c()
}
}
# Define "not in" operator
`%!in%` <- Negate(`%in%`)
gen_no <- 1000
##################### Organize Data for Slope Calculations #####################
# Read in FitnessTracker from Terra
FitnessTracker <- readRDS("FitnessTracker.rds")
# Remove ALL rows corresponding to final generation (fitnesses in these rows
# are NA)
FitnessTracker <- FitnessTracker[!is.na(FitnessTracker$Fitness),]
# Create subsets of FitnessTracker for each fusion class
# (No Fusion, Male-Benefit, Female-Benefit)
NF.FitnessTracker <- FitnessTracker[FitnessTracker$`Fused?` == 0,]
Fus.FitnessTracker <- FitnessTracker[(FitnessTracker$`Fused?` == 1) &
!is.na(FitnessTracker$`Fused SAL`),]
MB.FitnessTracker <- Fus.FitnessTracker[Fus.FitnessTracker$`Fused SAL` == 1,]
FB.FitnessTracker <- Fus.FitnessTracker[Fus.FitnessTracker$`Fused SAL` == 0,]
### Calculate slopes for lineages with male-benefit fusions
# find all unique male-benefit lineages
MB.lineages <- levels(as.factor(MB.FitnessTracker$`Paternal Lineage`))
# initialize Tips and HigherOrder
Tips <- c()
HigherOrder <- c()
# initialize number to report the number of decimals in the most recent lineage
MostDecimals <- 0
# record a complete lineage for each offshoot
for(i in 1:gen_no){
# check if this origin ever got a male-benefit fusion and, if so, group
# together all lineages with this origin
SameOrigin <- c()
for(m in 1:length(MB.lineages)){
if(substr(MB.lineages[m], 1, nchar(i) + 1) == paste(c(i, "."), collapse = "")){
SameOrigin <- append(SameOrigin, MB.lineages[m])
}
}
if(length(SameOrigin)){
# Find number of decimal places present in most recent lineages
for(x in 1:length(SameOrigin)){
if(nchar(strsplit(as.character(SameOrigin[x]), "\\.")[[1]][2]) > MostDecimals){
MostDecimals <- nchar(strsplit(as.character(SameOrigin[x]), "\\.")[[1]][2])
}
}
# Find the lineage(s) of this origin which were created most recently and
# store in Tips
for(x in 1:length(SameOrigin)){
if(nchar(strsplit(as.character(SameOrigin[x]), "\\.")[[1]][2]) == MostDecimals){
Tips <- append(Tips, SameOrigin[x])
}
}
MostDecimals <- 0
# check if ORIGINAL origin is present and, if so, add this to SameOrigin
# vector
if(i %in% MB.lineages){
SameOrigin <- append(SameOrigin, i)
}
# Store all the lineages which CREATED these lineages in HigherOrder
HigherOrder <- SameOrigin[SameOrigin %!in% Tips]
# If there are HigherOrder lineages...
if(length(HigherOrder)){
# For each lineage in HigherOrder...
for(p in 1:length(HigherOrder)){
# REPLICATE all MB.FitnessTracker rows where the HigherOrder lineage is present
# as many times as there are tips
DuplicatedRows <- c()
for(t in 1:length(Tips)){
if(length(grep(HigherOrder[p], substr(Tips[t],1,nchar(Tips[t])-1)))){
DuplicatedRows <- rbind(DuplicatedRows, MB.FitnessTracker[MB.FitnessTracker$`Paternal Lineage` == HigherOrder[p],])
# Rename the duplicated HigherOrder rows with the name in Tips
DuplicatedRows$`Paternal Lineage`[DuplicatedRows$`Paternal Lineage` == HigherOrder[p]] <- rep(Tips[t], sum(DuplicatedRows$`Paternal Lineage` == HigherOrder[p]))
}
}
# Add the replicated + renamed rows to MB.FitnessTracker and delete the
# original HigherOrder rows from MB.FitnessTracker
MB.FitnessTracker <- rbind(MB.FitnessTracker, DuplicatedRows)
MB.FitnessTracker <- subset(MB.FitnessTracker, `Paternal Lineage` != HigherOrder[p])
}
}
Tips <- c()
HigherOrder <- c()
}
}
############################### Calculate Slopes ###############################
### Male-Benefit
# Create factor of all the TERMINAL male-benefit lineages
MB.Tips <- levels(as.factor(MB.FitnessTracker$`Paternal Lineage`))
MB.Tips
# Initialize a dataframe in which to store slopes
# Lineage = Unique identifier of the terminal lineage
# First Fitness = Fitness of the lineage in the first generation in which the
# lineage receives a fusion
# Last Fitness = Fitness of the lineage in the final generation in which the
# lineage appears
# First Generation = Generation in which first member of lienage receives
# male-benefit fusion
# Last Generation = Final generation in which this lineage appears
# Slope = Change in fitness over change in generations
MB.Slopes <- dataframe(
Lineage = MB.Tips,
a = rep(NA, length(MB.Tips)),
b = rep(NA, length(MB.Tips)),
c = rep(NA, length(MB.Tips)),
d = rep(NA, length(MB.Tips)),
e = rep(NA, length(MB.Tips))
)
# Initialize a dataframe in which to store slopes
# Lineage = Unique identifier of the terminal lineage
# First Fitness = Fitness of the lineage in the first generation in which the
# lineage receives a fusion
# Last Fitness = Fitness of the lineage in the final generation in which the
# lineage appears
# First Generation = Generation in which first member of lienage receives
# male-benefit fusion
# Last Generation = Final generation in which this lineage appears
# Slope = Change in fitness over change in generations
MB.Slopes <- data.frame(
Lineage = MB.Tips,
a = rep(NA, length(MB.Tips)),
b = rep(NA, length(MB.Tips)),
c = rep(NA, length(MB.Tips)),
d = rep(NA, length(MB.Tips)),
e = rep(NA, length(MB.Tips))
)
MB.Slopes
names(MB.Slopes) <- c("Lineage", "First Fitness", "Last Fitness",
"First Generation", "Last Generation", "Slope")
MB.Slopes
i = 1
MB.FitnessTracker$Generation[MB.FitnessTracker$`Paternal Lineage` == MB.Tips[i]]
MB.FitnessTracker$Generation[
which.min(MB.FitnessTracker$Generation[
MB.FitnessTracker$`Paternal Lineage` == MB.Tips[i]])
]
MB.FitnessTracker$`Paternal Lineage` == MB.Tips[i]
which.min(MB.FitnessTracker$Generation[
MB.FitnessTracker$`Paternal Lineage` == MB.Tips[i]
])
# Get rows of all entries of this lineage
cur.lineage <- MB.FitnessTracker[
MB.FitnessTracker$`Paternal Lineage` == MB.Tips[i]
]
cur.lineage <- MB.FitnessTracker[
MB.FitnessTracker$`Paternal Lineage` == MB.Tips[i],
]
cur.lineage
which.min(cur.lineage$Generation)
cur.lineage$Generation[
which.min(cur.lineage$Generation)
]
# For each terminal male-benefit lineage...
for(i in 1:length(MB.Tips)){
# Get rows of all entries of this lineage
cur.lineage <- MB.FitnessTracker[
MB.FitnessTracker$`Paternal Lineage` == MB.Tips[i],
]
# Store first and last for both generation and fitness
MB.Slopes$`First Generation`[i] <- cur.lineage$Generation[which.min(cur.lineage$Generation)]
MB.Slopes$`First Fitness`[i] <- cur.lineage$Fitness[which.min(cur.lineage$Generation)]
MB.Slopes$`Last Generation`[i] <- cur.lineage$Generation[which.max(cur.lineage$Generation)]
MB.Slopes$`Last Fitness`[i] <- cur.lineage$Fitness[which.max(cur.lineage$Generation)]
# Calculate the difference between first and last fitness and first and last
# generation and store slope
MB.Slopes$Slope[i] <- (MB.Slopes$`Last Fitness` - MB.Slopes$`First Fitness`)/(MB.Slopes$`Last Generation` - MB.Slopes$`First Generation`)
}
warnings()
############################### Calculate Slopes ###############################
### Male-Benefit
# Create factor of all the TERMINAL male-benefit lineages
MB.Tips <- levels(as.factor(MB.FitnessTracker$`Paternal Lineage`))
# Initialize a dataframe in which to store slopes
# Lineage = Unique identifier of the terminal lineage
# First Fitness = Fitness of the lineage in the first generation in which the
# lineage receives a fusion
# Last Fitness = Fitness of the lineage in the final generation in which the
# lineage appears
# First Generation = Generation in which first member of lienage receives
# male-benefit fusion
# Last Generation = Final generation in which this lineage appears
# Slope = Change in fitness over change in generations
MB.Slopes <- data.frame(
Lineage = MB.Tips,
a = rep(NA, length(MB.Tips)),
b = rep(NA, length(MB.Tips)),
c = rep(NA, length(MB.Tips)),
d = rep(NA, length(MB.Tips)),
e = rep(NA, length(MB.Tips))
)
names(MB.Slopes) <- c("Lineage", "First Fitness", "Last Fitness",
"First Generation", "Last Generation", "Slope")
# For each terminal male-benefit lineage...
for(i in 1:length(MB.Tips)){
# Get rows of all entries of this lineage
cur.lineage <- MB.FitnessTracker[
MB.FitnessTracker$`Paternal Lineage` == MB.Tips[i],
]
# Store first and last for both generation and fitness
MB.Slopes$`First Generation`[i] <- cur.lineage$Generation[which.min(cur.lineage$Generation)]
MB.Slopes$`First Fitness`[i] <- cur.lineage$Fitness[which.min(cur.lineage$Generation)]
MB.Slopes$`Last Generation`[i] <- cur.lineage$Generation[which.max(cur.lineage$Generation)]
MB.Slopes$`Last Fitness`[i] <- cur.lineage$Fitness[which.max(cur.lineage$Generation)]
# Calculate the difference between first and last fitness and first and last
# generation and store slope
MB.Slopes$Slope[i] <- (MB.Slopes$`Last Fitness`[i] - MB.Slopes$`First Fitness`[i])/(MB.Slopes$`Last Generation`[i] - MB.Slopes$`First Generation`[i])
}
View(MB.Slopes)
# Retain only non-NA slopes
MB.Slopes <- MB.Slopes[!is.na(MB.Slopes$Slope),]
View(MB.Slopes)
foo <- readRDS("NF.FitnessTracker.rds")
tail(foo)
head(foo)
foo(foo$`Paternal Lineage` == 25)
foo[foo$`Paternal Lineage` == 25,]
head(foo, 50)
tail (foo)
foo[foo$`Paternal Lineage` == 666.144123322129,]
foo2 <-readRDS("MB.FitnessTracker.rds")
foo2[foo2$`Paternal Lineage` == 666.144123322129,]
foo[is.na(foo$`Fused SAL`),]
x <- foo[is.na(foo$`Fused SAL`),]
View(x)
View(foo2)
############################### Calculate Slopes ###############################
# Read in data from Terra run
MB.FitnessTracker <- readRDS("MB.FitnessTracker.rds")
############################### Calculate Slopes ###############################
# Read in data from Terra run
MB.FitnessTracker <- readRDS("MB.FitnessTracker.rds")
FB.FitnessTracker <- readRDS("FB.FitnessTracker.rds")
NF.FitnessTracker <- readRDS("NF.FitnessTracker.rds")
### Male-Benefit
# Create factor of all the TERMINAL male-benefit lineages
MB.Tips <- levels(as.factor(MB.FitnessTracker$`Paternal Lineage`))
# Initialize a dataframe in which to store slopes
# Lineage = Unique identifier of the terminal lineage
# First Fitness = Fitness of the lineage in the first generation in which the
# lineage receives a fusion
# Last Fitness = Fitness of the lineage in the final generation in which the
# lineage appears
# First Generation = Generation in which first member of lienage receives
# male-benefit fusion
# Last Generation = Final generation in which this lineage appears
# Slope = Change in fitness over change in generations
MB.Slopes <- data.frame(
Lineage = MB.Tips,
a = rep(NA, length(MB.Tips)),
b = rep(NA, length(MB.Tips)),
c = rep(NA, length(MB.Tips)),
d = rep(NA, length(MB.Tips)),
e = rep(NA, length(MB.Tips))
)
names(MB.Slopes) <- c("Lineage", "First Fitness", "Last Fitness",
"First Generation", "Last Generation", "Slope")
# For each terminal male-benefit lineage...
for(i in 1:length(MB.Tips)){
# Get rows of all entries of this lineage
cur.lineage <- MB.FitnessTracker[
MB.FitnessTracker$`Paternal Lineage` == MB.Tips[i],
]
# Store first and last for both generation and fitness
MB.Slopes$`First Generation`[i] <- cur.lineage$Generation[which.min(cur.lineage$Generation)]
MB.Slopes$`First Fitness`[i] <- cur.lineage$Fitness[which.min(cur.lineage$Generation)]
MB.Slopes$`Last Generation`[i] <- cur.lineage$Generation[which.max(cur.lineage$Generation)]
MB.Slopes$`Last Fitness`[i] <- cur.lineage$Fitness[which.max(cur.lineage$Generation)]
# Calculate the difference between first and last fitness and first and last
# generation and store slope
MB.Slopes$Slope[i] <- (MB.Slopes$`Last Fitness`[i] - MB.Slopes$`First Fitness`[i])/(MB.Slopes$`Last Generation`[i] - MB.Slopes$`First Generation`[i])
}
# Retain only non-NA slopes
MB.Slopes.NotNA <- MB.Slopes[!is.na(MB.Slopes$Slope),]
### Female-Benefit
# Create factor of all the TERMINAL female-benefit lineages
FB.Tips <- levels(as.factor(FB.FitnessTracker$`Paternal Lineage`))
# Initialize a dataframe in which to store slopes
# Lineage = Unique identifier of the terminal lineage
# First Fitness = Fitness of the lineage in the first generation in which the
# lineage receives a fusion
# Last Fitness = Fitness of the lineage in the final generation in which the
# lineage appears
# First Generation = Generation in which first member of lienage receives
# female-benefit fusion
# Last Generation = Final generation in which this lineage appears
# Slope = Change in fitness over change in generations
FB.Slopes <- data.frame(
Lineage = FB.Tips,
a = rep(NA, length(FB.Tips)),
b = rep(NA, length(FB.Tips)),
c = rep(NA, length(FB.Tips)),
d = rep(NA, length(FB.Tips)),
e = rep(NA, length(FB.Tips))
)
names(FB.Slopes) <- c("Lineage", "First Fitness", "Last Fitness",
"First Generation", "Last Generation", "Slope")
# For each terminal female-benefit lineage...
for(i in 1:length(FB.Tips)){
# Get rows of all entries of this lineage
cur.lineage <- FB.FitnessTracker[
FB.FitnessTracker$`Paternal Lineage` == FB.Tips[i],
]
# Store first and last for both generation and fitness
FB.Slopes$`First Generation`[i] <- cur.lineage$Generation[which.min(cur.lineage$Generation)]
FB.Slopes$`First Fitness`[i] <- cur.lineage$Fitness[which.min(cur.lineage$Generation)]
FB.Slopes$`Last Generation`[i] <- cur.lineage$Generation[which.max(cur.lineage$Generation)]
FB.Slopes$`Last Fitness`[i] <- cur.lineage$Fitness[which.max(cur.lineage$Generation)]
# Calculate the difference between first and last fitness and first and last
# generation and store slope
FB.Slopes$Slope[i] <- (FB.Slopes$`Last Fitness`[i] - FB.Slopes$`First Fitness`[i])/(FB.Slopes$`Last Generation`[i] - FB.Slopes$`First Generation`[i])
}
# Retain only non-NA slopes
FB.Slopes.NotNA <- FB.Slopes[!is.na(FB.Slopes$Slope),]
### No Fusion
# Create factor of all the TERMINAL no fusion lineages
NF.Tips <- levels(as.factor(NF.FitnessTracker$`Paternal Lineage`))
# Initialize a dataframe in which to store slopes
# Lineage = Unique identifier of the terminal lineage
# First Fitness = Fitness of the lineage in the first generation in which the
# lineage receives a fusion
# Last Fitness = Fitness of the lineage in the final generation in which the
# lineage appears
# First Generation = Generation in which first member of lienage receives
# no fusion fusion
# Last Generation = Final generation in which this lineage appears
# Slope = Change in fitness over change in generations
NF.Slopes <- data.frame(
Lineage = NF.Tips,
a = rep(NA, length(NF.Tips)),
b = rep(NA, length(NF.Tips)),
c = rep(NA, length(NF.Tips)),
d = rep(NA, length(NF.Tips)),
e = rep(NA, length(NF.Tips))
)
names(NF.Slopes) <- c("Lineage", "First Fitness", "Last Fitness",
"First Generation", "Last Generation", "Slope")
# For each terminal no fusion lineage...
for(i in 1:length(NF.Tips)){
# Get rows of all entries of this lineage
cur.lineage <- NF.FitnessTracker[
NF.FitnessTracker$`Paternal Lineage` == NF.Tips[i],
]
# Store first and last for both generation and fitness
NF.Slopes$`First Generation`[i] <- cur.lineage$Generation[which.min(cur.lineage$Generation)]
NF.Slopes$`First Fitness`[i] <- cur.lineage$Fitness[which.min(cur.lineage$Generation)]
NF.Slopes$`Last Generation`[i] <- cur.lineage$Generation[which.max(cur.lineage$Generation)]
NF.Slopes$`Last Fitness`[i] <- cur.lineage$Fitness[which.max(cur.lineage$Generation)]
# Calculate the difference between first and last fitness and first and last
# generation and store slope
NF.Slopes$Slope[i] <- (NF.Slopes$`Last Fitness`[i] - NF.Slopes$`First Fitness`[i])/(NF.Slopes$`Last Generation`[i] - NF.Slopes$`First Generation`[i])
}
# Retain only non-NA slopes
NF.Slopes.NotNA <- NF.Slopes[!is.na(NF.Slopes$Slope),]
################################ Run Statistics ################################
# Statistical Test A: Check if decay in fitness is greater for lineages with
# male-benefit fusions as opposed to lineages with no fusions
t.test(NF.Slopes.NotNA$Slope, NF.Slopes.NotNA$Slope)
################################ Run Statistics ################################
# Statistical Test A: Check if decay in fitness is greater for lineages with
# male-benefit fusions as opposed to lineages with no fusions
t.test(MB.Slopes.NotNA$Slope, NF.Slopes.NotNA$Slope)
# Statistical Test B: Check if decay in fitness is greater for lineages with
# female-benefit fusions as opposed to lineages with male-benefit fusions
t.test(MB.Slopes.NotNA$Slope, FB.Slopes.NotNA$Slope)
View(MB.Slopes)
View(MB.Slopes.NotNA)
View(FB.Slopes.NotNA)
View(NF.Slopes.NotNA)
t.test(abs(MB.Slopes.NotNA$Slope), abs(NF.Slopes.NotNA$Slope))
# Statistical Test B: Check if decay in fitness is greater for lineages with
# female-benefit fusions as opposed to lineages with male-benefit fusions
t.test(abs(MB.Slopes.NotNA$Slope), abs(FB.Slopes.NotNA$Slope))
mean(MB.Slopes.NotNA$Slope)
mean(NF.Slopes.NotNA$Slope)
mu <- 0.00000001
mu.table <- as.data.frame(
table(rbinom(n=100000, size=4*1587000, prob = mu))
)[1:4,2]/sum(as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))[1:4,2])
mu.table
mu <- 0.000000000001
mu.table <- as.data.frame(
table(rbinom(n=100000, size=4*1587000, prob = mu))
)[1:4,2]/sum(as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))[1:4,2])
mu.table
mu <- 0.000000000001
mu.table <- as.data.frame(
table(rbinom(n=100000, size=4*1587000, prob = mu))
)[1:4,2]/sum(as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))[1:4,2])
mu.table
mu <- 0.000000000001
mu.table <- as.data.frame(
table(rbinom(n=100000, size=4*1587000, prob = mu))
)[1:4,2]/sum(as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))[1:4,2])
mu.table
table(rbinom(n=100000, size=4*1587000, prob = mu))
# Get count of the probabilities of diff counts of mutations
count.probs <- rbinom(n=100000, size=4*1587000, prob = mu))
# Get count of the probabilities of diff counts of mutations
count.probs <- rbinom(n=100000, size=4*1587000, prob = mu)
count.probs
# Get count of the probabilities of diff counts of mutations
count.probs <- table(rbinom(n=100000, size=4*1587000, prob = mu))
count.probs
table(rbinom(n=100000, size=4*1587000, prob = mu))
table(rbinom(n=100000, size=4*1587000, prob = mu))
table(rbinom(n=100000, size=4*1587000, prob = mu))
table(rbinom(n=100000, size=4*1587000, prob = mu))
table(rbinom(n=100000, size=4*1587000, prob = mu))
count.probs[1:4,2]
length(count.probs)
nrow(count.probs)
ncol(count.probs)
table(1:4)
x<-table(1:4)
length(x)
table_length <- length(count.probs)
table_length
col_needed <- 4 - table_length
col_needed
as.data.frame(count.probs)
# Get count of the probabilities of diff counts of mutations
count.probs <- as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))
count.probs
mu <- 0.00000001
# Get count of the probabilities of diff counts of mutations
count.probs <- as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))
count.probs
count.probs[1:4,2]/sum(count.probs[1:4,2])
mu <- 0.000000000001
# Get count of the probabilities of diff counts of mutations
count.probs <- as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))
count.probs
count.probs[1:4,2]/sum(count.probs[1:4,2])
count.probs
nrow(count.probs)
table_length <- nrow(count.probs)
rows_needed <- 4 - table_length
rows_needed
rows_needed
4-rows_needed
(nrow(count.probs) + 1):4
c((nrow(count.probs) + 1):4, rep(0, rows_needed)
)
rbind(count.probs, c((nrow(count.probs) + 1):4, rep(0, rows_needed)))
count.probs
data.frame(
names(count.probs)[1] = nrow(count.probs) + 1):4,
names(count.probs)[2] = rep(0, rows_needed)
data.frame(
names(count.probs)[1] = nrow(count.probs) + 1):4,
names(count.probs)[2] = rep(0, rows_needed))
names(count.probs)[2]
names(count.probs)[1]
count.probs
nrow(count.probs) + 1):4
data.frame(
names(count.probs)[1] = (nrow(count.probs) + 1):4,
names(count.probs)[2] = rep(0, rows_needed))
data.frame(
names(count.probs)[1] = (nrow(count.probs) + 1):4,
names(count.probs)[2] = rep(0, rows_needed)
data.frame(
names(count.probs)[1] = (nrow(count.probs) + 1):4,
names(count.probs)[2] = rep(0, rows_needed))
(nrow(count.probs) + 1):4
rep(0, rows_needed)
data.frame(
names(count.probs)[1] = (nrow(count.probs) + 1):4,
names(count.probs)[2] = rep(0, rows_needed)
)
as.data.frame(
names(count.probs)[1] = (nrow(count.probs) + 1):4,
names(count.probs)[2] = rep(0, rows_needed)
)
as.data.frame((nrow(count.probs) + 1):4, rep(0, rows_needed))
data.frame((nrow(count.probs) + 1):4, rep(0, rows_needed))
rbind(count.probs, addition)
addition <- data.frame((nrow(count.probs) + 1):4, rep(0, rows_needed))
rbind(count.probs, addition)
colnames(addition) <- colnames(count.probs)
new_count.probs <- rbind(count.probs, addition)
new_count.probs
count.probs
addition
addition <- data.frame((nrow(count.probs)):4, rep(0, rows_needed))
addition <- data.frame((nrow(count.probs)):3, rep(0, rows_needed))
colnames(addition) <- colnames(count.probs)
new_count.probs <- rbind(count.probs, addition)
new_count.probs
count.probs
addition
?unfactor
typeof(count.probs$Var1)
typeof(count.probs$0)
typeof(count.probs[,2])
typeof(addition[,1])
typeof(addition[,2])
is.factor(addition[,2])
is.factor(addition[,1])
is.factor(count.probs[,1])
addition <- data.frame(as.factor(nrow(count.probs)):3, rep(0, rows_needed))
colnames(addition) <- colnames(count.probs)
new_count.probs <- rbind(count.probs, addition)
addition <- data.frame(as.factor(nrow(count.probs):3), rep(0, rows_needed))
colnames(addition) <- colnames(count.probs)
new_count.probs <- rbind(count.probs, addition)
new_count.probs
mu.table <- new_count.probs[1:4,2]/sum(new_count.probs[1:4,2])
mu.table
