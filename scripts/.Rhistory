# Pick 3 random sites OTHER than 13, 28, and 55 in...
# PAR (2:13), no recombination from 14:25
# Autosome I (27:49)
# Autosome II (52-99)
# ... at which recombination occurs (recombination CANNOT occur at first or
# final locus of a chromosome, so these loci are excluded)
SexRec <- sample(2:13, 1)
Chr1Rec <- sample(27:49, 1)
Chr2Rec <- sample(52:99, 1)
# For each chromosome, create two recombinant homologs and add to vectors
# from which gametes will be selected
SexChrGametes <- c(
paste(c(pop[[parents$Dads[i]]][1,1:(SexRec-1)],
pop[[parents$Dads[i]]][2,SexRec:25]), collapse = ","),
paste(c(pop[[parents$Dads[i]]][2,1:(SexRec-1)],
pop[[parents$Dads[i]]][1,SexRec:25]), collapse = ",")
)
Chr1Gametes <- c(
paste(c(pop[[parents$Dads[i]]][2,26:(Chr1Rec-1)],
pop[[parents$Dads[i]]][1,Chr1Rec:50]), collapse = ","),
paste(c(pop[[parents$Dads[i]]][1,26:(Chr1Rec-1)],
pop[[parents$Dads[i]]][2,Chr1Rec:50]), collapse = ",")
)
Chr2Gametes <- c(
paste(c(pop[[parents$Dads[i]]][2,51:(Chr2Rec-1)],
pop[[parents$Dads[i]]][1,Chr2Rec:100]), collapse = ","),
paste(c(pop[[parents$Dads[i]]][1,51:(Chr2Rec-1)],
pop[[parents$Dads[i]]][2,Chr2Rec:100]), collapse = ",")
)
# For each chromosome, randomly select ONE homolog from the two
# recombinant homologs and stick the 3 chromosomes together to create a
# haploid genome, adding this genome to the list of gametes under "sperm"
if(sum(pop[[parents$Dads[i]]][,25]) == 0){
gametes$sperm[i] <- paste(c(sample(SexChrGametes, 1),
sample(Chr1Gametes, 1),
sample(Chr2Gametes, 1)), collapse = ",")
}else if(1 %in% pop[[parents$Dads[i]]][,25]){
pick <- sample(1:2, 1)
gametes$sperm[i] <- paste(c(SexChrGametes[pick],
Chr1Gametes[pick],
sample(Chr2Gametes, 1)), collapse = ",")
}else if(2 %in% pop[[parents$Dads[i]]][,25]){
pick <- sample(1:2, 1)
gametes$sperm[i] <- paste(c(SexChrGametes[pick],
sample(Chr1Gametes, 1),
Chr2Gametes[pick]), collapse = ",")
}
}else{
pick <- sample(1:2, 3, replace = T)
gametes$sperm[i] <- paste(c(pop[[parents$Dads[i]]][pick[1],1:25],
pop[[parents$Dads[i]]][pick[2],26:50],
pop[[parents$Dads[i]]][pick[3],51:100]),
collapse = ",")
}
# For female..
# Pick 3 random sites OTHER than 13, 28, and 55 in...
# Sex chromosome (2:24)
# Autosome I (27:49)
# Autosome II (52-99)
# ... at which recombination occurs (recombination CANNOT occur at first or
# final locus of a chromosome, so these loci are excluded)
SexRec <- sample(2:24, 1)
Chr1Rec <- sample(27:49, 1)
Chr2Rec <- sample(52:99, 1)
# For each chromosome, create two recombinant homologs and add to vectors
# from which gametes will be selected
SexChrGametes <- c(
paste(c(pop[[parents$Moms[i]]][1,1:(SexRec-1)],
pop[[parents$Moms[i]]][2,SexRec:25]), collapse = ","),
paste(c(pop[[parents$Moms[i]]][2,1:(SexRec-1)],
pop[[parents$Moms[i]]][1,SexRec:25]), collapse = ",")
)
Chr1Gametes <- c(
paste(c(pop[[parents$Moms[i]]][2,26:(Chr1Rec-1)],
pop[[parents$Moms[i]]][1,Chr1Rec:50]), collapse = ","),
paste(c(pop[[parents$Moms[i]]][1,26:(Chr1Rec-1)],
pop[[parents$Moms[i]]][2,Chr1Rec:50]), collapse = ",")
)
Chr2Gametes <- c(
paste(c(pop[[parents$Moms[i]]][2,51:(Chr2Rec-1)],
pop[[parents$Moms[i]]][1,Chr2Rec:100]), collapse = ","),
paste(c(pop[[parents$Moms[i]]][1,51:(Chr2Rec-1)],
pop[[parents$Moms[i]]][2,Chr2Rec:100]), collapse = ",")
)
# For each chromosome, randomly select one homolog from the two
# recombinant homologs and stick these chromosomes together to create a
# haploid genome, adding this genome to the list of gametes under "eggs"
if(sum(pop[[parents$Moms[i]]][,25]) == 0){
gametes$eggs[i] <- paste(c(sample(SexChrGametes, 1),
sample(Chr1Gametes, 1),
sample(Chr2Gametes, 1)), collapse = ",")
}else if(1 %in% pop[[parents$Moms[i]]][,25]){
pick <- sample(1:2, 1)
gametes$eggs[i] <- paste(c(SexChrGametes[pick],
Chr1Gametes[pick],
sample(Chr2Gametes, 1)), collapse = ",")
}else if(2 %in% pop[[parents$Moms[i]]][,25]){
pick <- sample(1:2, 1)
gametes$eggs[i] <- paste(c(SexChrGametes[pick],
sample(Chr1Gametes, 1),
Chr2Gametes[pick]), collapse = ",")
}
}
# Return list of eggs and sperm
return(gametes)
}
# 7 make next gen and store the count of X or Y chromosomes (based on the
# fusion type) to later calculate frequency of fusions
# gametes = List of strings describing the haplotypes of available eggs and
# sperm where each locus' fitness value is separated by a comma
# newgen = List of matrices describing each of the new individuals
MiracleOfLife <- function(gametes, fus.type){
# New generation should be same size as number of couples
newgen <- vector(mode = "list", length = length(gametes$eggs))
# Initialize the count of fusions passed to this population as 0.
total_fus <- 0
# Depending on the type of fusion which is possible in this population,
# initialize total number chromosomes for frequency calculations as 0 or total
# number of X chromosomes as the population size (because every individual has
# at least one X and you later will add to this count based on whether each
# individual has an X or a Y chromosome)
if(fus.type == "Y"){
total_chr <- 0
}else if(fus.type == "X"){
total_chr <- length(gametes$eggs)
}
# Scramble the order of the eggs and sperm to pick a mom and dad at random
e <- sample(1:length(gametes$eggs))
s <- sample(1:length(gametes$sperm))
for(i in 1:length(newgen)){
# Combine 1 gamete from each randomly selected parent
egg_genome <- strsplit(gametes$eggs[e[i]], ",")[[1]]
sperm_genome <- strsplit(gametes$sperm[s[i]], ",")[[1]]
newgen[[i]] <- matrix(as.numeric(c(egg_genome, sperm_genome)),
nrow = 2, byrow = T)
# If locus at the SDR is a 1 and fusions can only occur to Y, iterate the
# count of total Y by 1.
if(newgen[[i]][2,13] & fus.type == "Y"){
total_chr =+ 1
}else if(!newgen[[i]][2,13] & fus.type == "X"){
# If this locus is an 0 and fusions can only occur to X, iterate count of
# X chromosomes by 1
total_chr =+ 1
}
# If this offspring has fusions, iterate the total number of fusions by the
# COUNT of fusion
if(sum(newgen[[i]][,25])){
total_fus =+ sum(newgen[[i]][,25] > 0)
}
}
# Return population, total number of Y chromosomes or X chromosomes in this
# new pop, and the count of fusions passed to this generation
return(list(newgen, total_chr, total_fus))
}
# Get a new population
pop <- GetPop(pop_size)
# Start the total number of fusions in this population at 0
total_fus <- 0
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu, fus.large)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm=T)
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_fus <- MoL_output[[3]]
total_chr
total_fus
length(gametes$eggs)
total_chr
total_chr =+ 1
total_chr
total_chr =+ 1
total_chr
# 7 make next gen and store the count of X or Y chromosomes (based on the
# fusion type) to later calculate frequency of fusions
# gametes = List of strings describing the haplotypes of available eggs and
# sperm where each locus' fitness value is separated by a comma
# newgen = List of matrices describing each of the new individuals
MiracleOfLife <- function(gametes, fus.type){
# New generation should be same size as number of couples
newgen <- vector(mode = "list", length = length(gametes$eggs))
# Initialize the count of fusions passed to this population as 0.
total_fus <- 0
# Depending on the type of fusion which is possible in this population,
# initialize total number chromosomes for frequency calculations as 0 or total
# number of X chromosomes as the population size (because every individual has
# at least one X and you later will add to this count based on whether each
# individual has an X or a Y chromosome)
if(fus.type == "Y"){
total_chr <- 0
}else if(fus.type == "X"){
total_chr <- length(gametes$eggs)
}
# Scramble the order of the eggs and sperm to pick a mom and dad at random
e <- sample(1:length(gametes$eggs))
s <- sample(1:length(gametes$sperm))
for(i in 1:length(newgen)){
# Combine 1 gamete from each randomly selected parent
egg_genome <- strsplit(gametes$eggs[e[i]], ",")[[1]]
sperm_genome <- strsplit(gametes$sperm[s[i]], ",")[[1]]
newgen[[i]] <- matrix(as.numeric(c(egg_genome, sperm_genome)),
nrow = 2, byrow = T)
# If locus at the SDR is a 1 and fusions can only occur to Y, iterate the
# count of total Y by 1.
if(newgen[[i]][2,13] & fus.type == "Y"){
total_chr <- total_chr + 1
}else if(!newgen[[i]][2,13] & fus.type == "X"){
# If this locus is an 0 and fusions can only occur to X, iterate count of
# X chromosomes by 1
total_chr <- total_chr + 1
}
# If this offspring has fusions, iterate the total number of fusions by the
# COUNT of fusion
if(sum(newgen[[i]][,25])){
total_fus <- total_fus + sum(newgen[[i]][,25] > 0)
}
}
# Return population, total number of Y chromosomes or X chromosomes in this
# new pop, and the count of fusions passed to this generation
return(list(newgen, total_chr, total_fus))
}
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_chr
total_fus <- MoL_output[[3]]
total_fus
# Calculate and store frequency fusions at this generation. The functions
# already account for the fact that the total number of chromosomes to
# which a fusion could possibly occur (stored in total_chr) varies based
# on the type of fusion (X or Y) possible in this run
fusion_frequencies[gen, sim] <- total_fus/total_chr
rep("Sim:", num_sims)
apply(c(rep("Sim:", num_sims), 1:num_sims), paste)
apply(c(rep("Sim:", num_sims), 1:num_sims), FUN = paste)
?paste
rep("Sim:", num_sims)
apply(rep("Sim:", num_sims), FUN = paste(1:num_sims))
apply(rep("Sim:", num_sims), FUN = paste)
paste(c(rep("Sim:", num_sims), 1:num_sims))
paste(1:num_sims, collapse = "Sim:")
paste(0:num_sims, collapse = "Sim:")
strsplit(paste(0:num_sims, collapse = ",Sim:"), ",")[[1]]
strsplit(paste(0:num_sims, collapse = ",Sim:"), ",")[[1]][-1]
strsplit(paste(0:num_sims, collapse = ",Sim: "), ",")[[1]][-1]
# Initialize a matrix with as many rows as there are generations and as many
# columns as there are simulations
fusion_frequencies <- matrix(ncol = num_sims, nrow = gen_no,
dimnames = strsplit(paste(0:gen_no, collapse = ",Gen: "), ",")[[1]][-1])
strsplit(paste(0:gen_no, collapse = ",Gen: "), ",")[-1]
strsplit(paste(0:gen_no, collapse = ",Gen: "), ",")
# Initialize a matrix with as many rows as there are generations and as many
# columns as there are simulations
fusion_frequencies <- matrix(ncol = num_sims, nrow = gen_no,
dimnames = list(strsplit(paste(0:gen_no, collapse = ",Gen: "), ",")[[1]][-1]))
fusion_frequencies
# Name columns by sims and rows by generations
colnames(fusion_frequencies) <- strsplit(paste(0:num_sims, collapse = ",Sim: "), ",")[[1]][-1]
fusion_frequencies
fusion_frequencies[gen, sim]
# Initialize a matrix with as many rows as there are generations and as many
# columns as there are simulations
fusion_frequencies <- matrix(ncol = num_sims, nrow = gen_no,
dimnames = list(strsplit(paste(0:gen_no, collapse = ",Gen: "), ",")[[1]][-1]))
# Name columns by sims and rows by generations
colnames(fusion_frequencies) <- strsplit(paste(0:num_sims, collapse = ",Sim: "), ",")[[1]][-1]
# Get a distribution of fitness effects
dfe <- GetDFE()
# Get a new population
pop <- GetPop(pop_size)
# Start the total number of fusions in this population at 0
total_fus <- 0
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu, fus.large)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm=T)
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
MoL_output
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_fus <- MoL_output[[3]]
# Calculate and store frequency fusions at this generation. The functions
# already account for the fact that the total number of chromosomes to
# which a fusion could possibly occur (stored in total_chr) varies based
# on the type of fusion (X or Y) possible in this run
fusion_frequencies[gen, sim] <- total_fus/total_chr
gen
gen = 2
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu, fus.large)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm=T)
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_fus <- MoL_output[[3]]
total_chr
total_fus
# Calculate and store frequency fusions at this generation. The functions
# already account for the fact that the total number of chromosomes to
# which a fusion could possibly occur (stored in total_chr) varies based
# on the type of fusion (X or Y) possible in this run
fusion_frequencies[gen, sim] <- total_fus/total_chr
fusion_frequencies
sim = 2
gen = 1
# Get a new population
pop <- GetPop(pop_size)
# Start the total number of fusions in this population at 0
total_fus <- 0
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu, fus.large)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm=T)
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_fus <- MoL_output[[3]]
total_fus
# Calculate and store frequency fusions at this generation. The functions
# already account for the fact that the total number of chromosomes to
# which a fusion could possibly occur (stored in total_chr) varies based
# on the type of fusion (X or Y) possible in this run
fusion_frequencies[gen, sim] <- total_fus/total_chr
# 6 lay down mutations
# mu = mutation rate
# pop = list of N genomes
# fus.large:
#         T = fusions can occur only between sex and LARGE autosomes
#         F = fusions can occur only between sex and SMALL autosomes
ActofGod <- function(pop, dfe, fus.type, mu, fus.large){
# Initialize a vector to store sites which receive mutations
mut_sites <- rep(0, ncol(pop[[1]]))
# Iterate through each individual
for(i in 1:length(pop)){
# Decide which sites in this individual, if any, get mutations
mut_sites[-c(13,25,28,55)] <- sample(0:1, size = (length(mut_sites) - 4), prob = c(1-mu, mu), replace = T)
# If the individual gets any mutations...
if(sum(mut_sites)){
# At each site to be mutated, replace the value of a random homolog with
# a randomly-selected value from dfe
# In case Heath asks why you are LOOPING through all mutated sites:
# If you were to instead do this...
# pop[[i]][sample(1:2, size = 1), mut_sites[locus]]
# ...ALL mutations would be added to the SAME homolog (1 or 2)
for(locus in which(mut_sites == 1)){
pop[[i]][sample(1:2, size = 1), mut_sites[locus]] <-
sample(dfe, size = 1)
}
}
}
# Get indices of males and females to later sample from
F.indx <- c()
M.indx <- c()
checker <- function(x){
x[2,13] == 0
}
females <- unlist(lapply(pop, FUN=checker))
# Each generation has 10% chance of having 1 individual with a fusion
# TODO change prob back to c(0.9,0.1)
fuse.bool <- sample(0:1, size = 1, prob = c(0,1))
# If this is one of the generations with a fusion, randomly sample an
# applicable chromosome (X or Y) to which the fusion should be introduced
if(fuse.bool){
if(fus.type == "X"){
# Choose whether a male (1) or female (0) gets the fusion. Females are
# 2x as likely to get X fusions because they have 2 X chr
fuse.sex <- sample(0:1, size = 1, prob = c(2, 1))
# Sample a random individual of the select sex
if(fuse.sex){
fuse.indv <- sample(which(!females), size = 1)
# If male was selected to be fused, sample only the X chr
fuse.chr <- 1
}else{
fuse.indv <- sample(which(females), size = 1)
# If female was selected to be fused, sample 1 of the X chr
fuse.chr <- sample(1:2, size = 1)
}
# Check if the sampled X is already fused
if(!pop[[fuse.indv]][fuse.chr, 25]){
# If not, introduce large or small fusion based on value of "fus.large"
if(fus.large){
pop[[fuse.indv]][fuse.chr, 25] <- 2
}else{
pop[[fuse.indv]][fuse.chr, 25] <- 1
}
}
# If only Y is permitted to have fusions, select a male, check if he already
# has a fusion, then introduce fusion to Y
}else if(fus.type == "Y"){
fuse.indv <- sample(which(!females), size = 1)
if(!pop[[fuse.indv]][2, 25]){
# introduce large or small fusion based on value of "fus.large"
if(fus.large){
pop[[fuse.indv]][2, 25] <- 2
}else{
pop[[fuse.indv]][2, 25] <- 1
}
}
}
}
# Return the population
return(pop)
}
print(paste("Total Chromosomes: ", total_chr, ". Total Fusions: ", total_fus), collapse = "")
# Runs the simulation on "pop_size" number of individuals for "gen_no"
# generations with an SAL selection coefficient of "s"
# fus.type "X" or "Y" for which chrom is fused to.
# fus.large:
#         T = fusions can occur only between sex and LARGE autosomes
#         F = fusions can occur only between sex and SMALL autosomes
Evolve <- function(num_sims, pop_size, gen_no, s, chiasm, fus.type, mu, fus.large){
# Initialize a matrix with as many rows as there are generations and as many
# columns as there are simulations
fusion_frequencies <- matrix(ncol = num_sims, nrow = gen_no,
dimnames = list(strsplit(paste(0:gen_no, collapse = ",Gen: "), ",")[[1]][-1]))
# Name columns by sims and rows by generations
colnames(fusion_frequencies) <- strsplit(paste(0:num_sims, collapse = ",Sim: "), ",")[[1]][-1]
# Get a distribution of fitness effects
dfe <- GetDFE()
for(sim in 1:num_sims){
print(paste("Simulation: ", sim, collapse = ""))
# Get a new population
pop <- GetPop(pop_size)
# Start the total number of fusions in this population at 0
total_fus <- 0
# For each generation in "gen_no"...
for(gen in 1:gen_no){
print(paste(c("Generation: ", gen), collapse = ""))
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu, fus.large)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm=T)
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_fus <- MoL_output[[3]]
print(paste("Total Chromosomes: ", total_chr, " Total Fusions: ", total_fus), collapse = "")
# Calculate and store frequency fusions at this generation. The functions
# already account for the fact that the total number of chromosomes to
# which a fusion could possibly occur (stored in total_chr) varies based
# on the type of fusion (X or Y) possible in this run
fusion_frequencies[gen, sim] <- total_fus/total_chr
}
}
# Output final frequencies after all sims and generations
return(fusion_frequencies)
}
num_sims <- 2
gen_no <- 2
s <- 0
pop_size <- 10
chiasm <- T
fus.type <- "X"
fus.large <- F
mu <- 0
results <- Evolve(num_sims, pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
View(results)
1/15
fus.large <- T
results <- Evolve(num_sims, pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
3/19
2/15
3/15
fus.type <- "Y"
results <- Evolve(num_sims, pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
5/9
4/6
8/8
fus.large <- F
results <- Evolve(num_sims, pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
3/7
1/3
