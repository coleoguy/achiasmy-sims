print(paste(c("Generation: ", gen), collapse = ""))
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu, fus.large)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm=T)
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_fus <- MoL_output[[3]]
print(paste("Total Chromosomes: ", total_chr, " Total Fusions: ", total_fus), collapse = "")
# Calculate and store frequency fusions at this generation. The functions
# already account for the fact that the total number of chromosomes to
# which a fusion could possibly occur (stored in total_chr) varies based
# on the type of fusion (X or Y) possible in this run
fusion_frequencies[gen, sim] <- total_fus/total_chr
}
}
)
gen_no <- 100
fusion_frequencies <- matrix(ncol = num_sims, nrow = gen_no, dimnames = list(strsplit(paste(0:gen_no, collapse = ",Gen: "), ",")[[1]][-1]))
colnames(fusion_frequencies) <- strsplit(paste(0:num_sims, collapse = ",Sim: "), ",")[[1]][-1]
dfe <- GetDFE()
profvis(expr =
for(sim in 1:num_sims){
print(paste("Simulation: ", sim, collapse = ""))
# Get a new population
pop <- GetPop(pop_size)
# Start the total number of fusions in this population at 0
total_fus <- 0
# For each generation in "gen_no"...
for(gen in 1:gen_no){
print(paste(c("Generation: ", gen), collapse = ""))
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu, fus.large)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm=T)
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_fus <- MoL_output[[3]]
print(paste("Total Chromosomes: ", total_chr, " Total Fusions: ", total_fus), collapse = "")
# Calculate and store frequency fusions at this generation. The functions
# already account for the fact that the total number of chromosomes to
# which a fusion could possibly occur (stored in total_chr) varies based
# on the type of fusion (X or Y) possible in this run
fusion_frequencies[gen, sim] <- total_fus/total_chr
}
}
)
source("functions.R")
num_sims <- 2
gen_no <- 100
s <- 0.3
pop_size <- 1000
chiasm <- T
fus.type <- "Y"
fus.large <- F
mu <- 10^-8
View(results)
View(results)
fusion_frequencies <- matrix(ncol = num_sims, nrow = gen_no, dimnames = list(strsplit(paste(0:gen_no, collapse = ",Gen: "), ",")[[1]][-1]))
colnames(fusion_frequencies) <- strsplit(paste(0:num_sims, collapse = ",Sim: "), ",")[[1]][-1]
dfe <- GetDFE()
profvis(expr =
for(sim in 1:num_sims){
print(paste("Simulation: ", sim, collapse = ""))
# Get a new population
pop <- GetPop(pop_size)
# Start the total number of fusions in this population at 0
total_fus <- 0
# For each generation in "gen_no"...
for(gen in 1:gen_no){
print(paste(c("Generation: ", gen), collapse = ""))
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu, fus.large)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm=T)
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_fus <- MoL_output[[3]]
# Calculate and store frequency fusions at this generation. The functions
# already account for the fact that the total number of chromosomes to
# which a fusion could possibly occur (stored in total_chr) varies based
# on the type of fusion (X or Y) possible in this run
fusion_frequencies[gen, sim] <- total_fus/total_chr
}
}
)
source("functions.R")
num_sims <- 1
gen_no <- 1
s <- 0.3
pop_size <- 1000
chiasm <- T
fus.type <- "Y"
fus.large <- F
mu <- 10^-8
fusion_frequencies <- matrix(ncol = num_sims, nrow = gen_no, dimnames = list(strsplit(paste(0:gen_no, collapse = ",Gen: "), ",")[[1]][-1]))
fusion_frequencies
colnames(fusion_frequencies) <- strsplit(paste(0:num_sims, collapse = ",Sim: "), ",")[[1]][-1]
dfe <- GetDFE()
profvis(expr =
for(sim in 1:num_sims){
print(paste("Simulation: ", sim, collapse = ""))
# Get a new population
pop <- GetPop(pop_size)
# Start the total number of fusions in this population at 0
total_fus <- 0
# For each generation in "gen_no"...
for(gen in 1:gen_no){
print(paste(c("Generation: ", gen), collapse = ""))
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu, fus.large)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm=T)
# Breed the parents, record the total number of X or Y chr (depending
# on the type of fusions which are possible), and record the total number
# of fusions passed to the new population
MoL_output <- MiracleOfLife(gametes, fus.type)
pop <- MoL_output[[1]]
total_chr <- MoL_output[[2]]
total_fus <- MoL_output[[3]]
# Calculate and store frequency fusions at this generation. The functions
# already account for the fact that the total number of chromosomes to
# which a fusion could possibly occur (stored in total_chr) varies based
# on the type of fusion (X or Y) possible in this run
fusion_frequencies[gen, sim] <- total_fus/total_chr
}
}
)
num_sims <- 10
gen_no <- 1000
s <- 0.3
pop_size <- 1000
chiasm <- T
fus.type <- "Y"
fus.large <- F
mu <- 10^-14
source("functions.R")
start.time <- proc.time()
results <- Evolve(num_sims, pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
total.time <- proc.time() - start.time
num_sims <- 1
start.time <- proc.time()
results <- Evolve(num_sims, pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
total.time <- proc.time() - start.time
job_hours <- ((16*10*total.time)/1000)/(60*60)
job_hours
total.time
total.time[1]
total.time[[1]]
total.time[[1]]
(total.time[[1]])/(60*60)
job_hours <- 16*10*(total.time[[1]])/(60*60)
job_hours
job_hours/4
paste(c("C","Y","S",".rds"))
paste(c("C","Y","S",".rds"), collapse = "")
num_conditions <- 8
num_conditions
remainder(2)
?remainder
2/2
1/2
5%%2
cond = 1
cond%%2
cond = 2
cond%%2
3%%2
4%%2
5%%2
6%%2
7%%2
8%%2
cond <= 4
1%%4
2%%4
3%%4
4%%4
(2%%4)%%2
cond == (3 | 4 | 7 | 8)
cond
cond == (1 | 2 | 5 | 6)
cond
cond %in% c(1, 2, 5, 6)
cond
cond = 3
cond %in% c(1, 2, 5, 6)
# Name file based on current parameters
if(chiasm){
meiotic_type <- "C"
}else{
meiotic_type <- "A"
}
# Run first 4 sims chiasmatic and final four achiasmatic
if(cond <= 4){
chiasm <- T
}else{
chiasm <- F
}
# Name file based on current parameters
if(chiasm){
meiotic_type <- "C"
}else{
meiotic_type <- "A"
}
meiotic_type
# Every 2 runs, switch fusing from Y to X
if(cond %in% c(1, 2, 5, 6)){
fus.type <- "Y"
}else{
fus.type <- "X"
}
# Every other run, switch from small to large
if(cond%%2){
fus.large <- F
}else{
fus.large <- T
}
if(fus.large){
size <- "L"
}else{
size <- "S"
}
size
fus.type
filename <- paste(c(meiotic_type, fus.type, size, ".rds"), collapse = "")
filename
paste(c(meiotic_type, fus.type, size, "_", mu, ".rds"),
collapse = "")
mu <- 5e-7
mu <- mu/10
mu
num_sims <- 1
gen_no <- 1
pop_size <- 1000
s <- 0
mu <- 5e-8
# Run with mutation rates 5e-8 through 5e-10
for(mut_rate in 1:3){
# Run with each possible combination of parameters. There are 8 possible
# combinations of parameters because there are 2 values each for "chiasm",
# "fus.type", and "fus.size"
for(cond in 1:8){
# Run first 4 sims chiasmatic and final four achiasmatic
if(cond <= 4){
chiasm <- T
}else{
chiasm <- F
}
# Every 2 runs, switch fusing from Y to X
if(cond %in% c(1, 2, 5, 6)){
fus.type <- "Y"
}else{
fus.type <- "X"
}
# Every other run, switch from small to large
if(cond%%2){
fus.large <- F
}else{
fus.large <- T
}
# Run sims
res <- Evolve(num_sims, pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
# Name file based on current parameters
if(chiasm){
meiotic_type <- "C"
}else{
meiotic_type <- "A"
}
if(fus.large){
size <- "L"
}else{
size <- "S"
}
filename <- paste(c(meiotic_type, fus.type, size, "_", mu, ".rds"),
collapse = "")
saveRDS(res, filename)
}
# Move to the next lowest mutation rate
mu <- mu/10
}
source("functions.R")
num_sims <- 1
gen_no <- 1
pop_size <- 1000
s <- 0
mu <- 5e-8
# Run with mutation rates 5e-8 through 5e-10
for(mut_rate in 1:3){
# Run with each possible combination of parameters. There are 8 possible
# combinations of parameters because there are 2 values each for "chiasm",
# "fus.type", and "fus.size"
for(cond in 1:8){
# Run first 4 sims chiasmatic and final four achiasmatic
if(cond <= 4){
chiasm <- T
}else{
chiasm <- F
}
# Every 2 runs, switch fusing from Y to X
if(cond %in% c(1, 2, 5, 6)){
fus.type <- "Y"
}else{
fus.type <- "X"
}
# Every other run, switch from small to large
if(cond%%2){
fus.large <- F
}else{
fus.large <- T
}
# Run sims
res <- Evolve(num_sims, pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
# Name file based on current parameters
if(chiasm){
meiotic_type <- "C"
}else{
meiotic_type <- "A"
}
if(fus.large){
size <- "L"
}else{
size <- "S"
}
filename <- paste(c(meiotic_type, fus.type, size, "_", mu, ".rds"),
collapse = "")
saveRDS(res, filename)
}
# Move to the next lowest mutation rate
mu <- mu/10
}
warnings()
chr2.bool
chr2.bool <- sample(1:0, prob = c(0.08, 0.92))
chr2.bool
chr2.bool <- sample(1:0, size = 1, prob = c(0.08, 0.92))
chr2.bool
# To ensure that recombinations between SDR and SAL have SAME probability
# for both large and small chromosomes, make there be a 0.08 probability
# of selecting a site to the left of the SAL and a 0.92 probability of
# selecting a site to the right of the SAL for both chr1 (small) and chr2
# (large)
chr1.bool <- sample(1:0, size = 1, prob = c(0.08, 0.92))
chr1.bool
source("functions.R")
num_sims <- 1
gen_no <- 1
pop_size <- 1000
s <- 0
mu <- 5e-8
paste(c(meiotic_type, fus.type, size, "_", Sys.Date(), ".rds"),
collapse = "")
Sys.Date()
paste(c(meiotic_type, fus.type, size, "_", as.character(Sys.Date()), ".rds"),
collapse = "")
source("functions.R")
# Create a cluster to run each simulation simultaneously
sim_cluster <- makeCluster(spec = 100, type = "SOCK")
registerDoSNOW(cl = sim_cluster)
num_sims <- 2
gen_no <- 1000
pop_size <- 1000
s <- 0
mu <- 5e-9
# Run with each possible combination of parameters. There are 8 possible
# combinations of parameters because there are 2 values each for "chiasm",
# "fus.type", and "fus.size"
num_conditions <- 8
# Create matrix where...
# row = generation
# column = simulation
# cell = frequency of fusions
fusion_frequencies <- matrix(nrow = gen_no, ncol = num_sims)
# Run sims in parallel and store the resulting fusion frequencies after each
# generation as a column
foreach(sim = 1:num_sims) %dopar% {
col <- Evolve(pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
fusion_frequencies[, sim] <- col
}
chiasm <- T
fus.type <- "Y"
fus.large <- F
# Prep filename based on current parameters
filename <- paste(c(meiotic_type, fus.type, size, "_",
as.character(Sys.Date()), ".rds"), collapse = "")
print(filename)
# Create matrix where...
# row = generation
# column = simulation
# cell = frequency of fusions
fusion_frequencies <- matrix(nrow = gen_no, ncol = num_sims)
fusion_frequencies
col <- Evolve(pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
# Run sims in parallel and store the resulting fusion frequencies after each
# generation as a column
foreach(sim = 1:num_sims) %dopar% {
print(paste(c("Simulation: ", sim), collapse = ""))
col <- Evolve(pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
fusion_frequencies[, sim] <- col
}
# Create a cluster to run each simulation simultaneously
nCores <- detectCores() - 1
# variables
# s: the selection coefficient for SA .5
# dfe: vector of selection coefficients for general fitness loci
# gen: number of generations to run
# iter: number of trials to use
#
library("parallel")
library("doSNOW")
library("foreach")
# Create a cluster to run each simulation simultaneously
nCores <- detectCores() - 1
nCores
sim_cluster <- makeCluster(spec = nCores, type = "SOCK")
registerDoSNOW(cl = sim_cluster)
num_sims <- 2
gen_no <- 1000
pop_size <- 1000
s <- 0
mu <- 5e-9
# Run with each possible combination of parameters. There are 8 possible
# combinations of parameters because there are 2 values each for "chiasm",
# "fus.type", and "fus.size"
num_conditions <- 8
# Prep filename based on current parameters
filename <- paste(c(meiotic_type, fus.type, size, "_",
as.character(Sys.Date()), ".rds"), collapse = "")
print(filename)
# Create matrix where...
# row = generation
# column = simulation
# cell = frequency of fusions
fusion_frequencies <- matrix(nrow = gen_no, ncol = num_sims)
# Run sims in parallel and store the resulting fusion frequencies after each
# generation as a column
foreach(sim = 1:num_sims) %dopar% {
print(paste(c("Simulation: ", sim), collapse = ""))
col <- Evolve(pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
fusion_frequencies[, sim] <- col
}
foreach(sim = 1:num_sims) %dopar% {
print(paste(c("Simulation: ", sim), collapse = ""))
}
# Create matrix where...
# row = generation
# column = simulation
# cell = frequency of fusions
fusion_frequencies <- matrix(nrow = gen_no, ncol = num_sims)
# Run sims in parallel and store the resulting fusion frequencies after each
# generation as a column
foreach(sim = 1:num_sims) %dopar% {
print(paste(c("Simulation: ", sim), collapse = ""))
col <- Evolve(pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
fusion_frequencies[, sim] <- col
}
source("functions.R")
# Create a cluster to run each simulation simultaneously
nCores <- detectCores() - 1
sim_cluster <- makeCluster(spec = nCores, type = "SOCK")
registerDoSNOW(cl = sim_cluster)
num_sims <- 2
gen_no <- 1000
pop_size <- 1000
s <- 0
mu <- 5e-9
# Prep filename based on current parameters
filename <- paste(c(meiotic_type, fus.type, size, "_",
as.character(Sys.Date()), ".rds"), collapse = "")
print(filename)
# Create matrix where...
# row = generation
# column = simulation
# cell = frequency of fusions
fusion_frequencies <- matrix(nrow = gen_no, ncol = num_sims)
fusion_frequencies
?matrix
# Run sims in parallel and store the resulting fusion frequencies after each
# generation as a column
foreach(sim = 1:num_sims) %dopar% {
print(paste(c("Simulation: ", sim), collapse = ""))
col <- Evolve(pop_size, gen_no, s, chiasm, fus.type, mu, fus.large)
fusion_frequencies[, sim] <- col
}
